<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<!-- <title>Trustonic Tests: 00100_BufferSizes_CA2TA_OpenSession</title> -->
<img align="right" width="300" src="TrustonicLogo.jpg">
</br>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>00100_BufferSizes_CA2TA_OpenSession<br/>
<small>
[<a class="el" href="group___g_p__060___buffer_limitations.html">GP_060_BufferLimitations</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#ga47769028dbfd38bb9ff4de5c4d66ff35">TestCase_GC00100_ZeroLengthBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#gaeab19b1ba1cbc3f6a401658046f301bf">TestCase_GC00110_BufferPageUnalignedAtStart</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#gaddbf90a1b5994d0d96d859424709a5d1">TestCase_GC00120_BufferPageUnalignedAtEnd</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#gad1b445e921ad70c26dc6ad72a143a0e8">TestCase_GC00130_LargeBuff_1MB_Align4KB</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#ga4aab97e3c902f116f2652c0585665bf3">TestCase_BC00131_LargeBuff_1MB_Unaligned</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#ga35da4c5ad158b2f65c13d3965d1f723f">TestCase_GC00132_MaximumLengthBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#ga96f880a658691f0e4781c0a9f7510230">TestCase_BC00140_BufferTooLarge</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#ga2c9a8d493cd51ca3d83613acbe022746">TestCase_GC00150_InputBufferReadOnly</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#gaa1f409c364dc44d22923f4fd19255d06">TestCase_BC00151_OutputBufferReadOnly</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#gaddb1ab9e270541ceb4d25fe01019e2cd">TestCase_BC00152_InOutBufferReadOnly</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#gab21c59a5aa0516995eb9507b55e89063">TestCase_GC00160_BufferLengthStress</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___open_session.html#ga9aeb03dbf5d9b827c412b100189de946">TestCase_GC00165_BufferLengthStressMultiThreaded</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Description:</b></dt><dd>: Verify that various buffer sizes can be used, with attention to boundary conditions.</dd></dl>
<p>TEEC_Result TEEC_OpenSession ( TEEC_Context* context, TEEC_Session* session, const TEEC_UUID* destination, uint32_t connectionMethod, const void* connectionData, TEEC_Operation* operation, uint32_t* returnOrigin );</p>
<p>The TAs are the same as for the other TA modes tests.</p>
<p>CA setup: Set up one or more buffer(s) and fill them with random data Call the TA using TEEC_OpenTASession()</p>
<p>Algorithm for choosing a TA to use:</p>
<ul>
<li>pick a random TA until one is picked that is not in use:<ul>
<li>multisession = 1 allowed</li>
<li>monosession = 1 allowed</li>
<li>multisession_keepalive = 1 allowed</li>
<li>monosession_keepalive = 1 allowed</li>
<li>multiinstance &gt; 1 are allowed</li>
</ul>
</li>
<li>track when a TA is in use</li>
<li>track when a TA is closed and then is available</li>
</ul>
<p>TA: read the contents of an input or an inout buffer and calculate a checksum write data into an output or an inout buffer return TEE_SUCCESS</p>
<p>CA tear down: Close the session, expect TEE_SUCCESS </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga47769028dbfd38bb9ff4de5c4d66ff35"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00100_ZeroLengthBuffers" ref="ga47769028dbfd38bb9ff4de5c4d66ff35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00100_ZeroLengthBuffers </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass zero as the length for one to four buffers in various combinations of NONE and MEMREFs </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a random length of 8-128 for all that are not of type NONE fill the buffers with random data and calculate a checksum for each type that is a MEMREF, randomly choose an offset to pass as a start address in the corresponding buffer Open a TA of a random mode, use ZERO as the length for each buffer, and expect '0' as the return value from the TA If the return value is 0: Close the TA Verify that the TA did not die Calculate the checksum again to verify that the buffers did not change </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00100_ZeroLengthBuffers </dd></dl>

</div>
</div>
<a class="anchor" id="gaeab19b1ba1cbc3f6a401658046f301bf"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00110_BufferPageUnalignedAtStart" ref="gaeab19b1ba1cbc3f6a401658046f301bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00110_BufferPageUnalignedAtStart </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass multiple buffers of just over one page in length. Vary the start offset randomly, but fix the end at the exact end of a page. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 15: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate 3 * 4096 bytes for each buffer fix the end of the buffer at the end of the 2nd page randomly choose the length of the buffer to be between 4096+1 and 4096+16 in size, causing a page overlap near the start of the buffer fill the buffer(s) with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA Open a TA of a random mode, use the length from above as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00110_BufferPageUnalignedAtStart </dd></dl>

</div>
</div>
<a class="anchor" id="gaddbf90a1b5994d0d96d859424709a5d1"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00120_BufferPageUnalignedAtEnd" ref="gaddbf90a1b5994d0d96d859424709a5d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00120_BufferPageUnalignedAtEnd </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass multiple buffers of just over one page in length. Vary the end position randomly, but fix the start at the exact start of a page. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 15: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate 3 * 4096 bytes for each buffer fix the start of the buffer at the start of the 2nd page randomly choose the length of the buffer to be between 4096 and 4096+16 in size, causing a page overlap near the end of the buffer fill the buffer(s) with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA Open a TA of a random mode, use the length from above as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00120_BufferPageUnalignedAtEnd </dd></dl>

</div>
</div>
<a class="anchor" id="gad1b445e921ad70c26dc6ad72a143a0e8"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00130_LargeBuff_1MB_Align4KB" ref="gad1b445e921ad70c26dc6ad72a143a0e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00130_LargeBuff_1MB_Align4KB </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+32 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode, use MAX as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00130_LargeBuff_1MB_Align4KB </dd></dl>

</div>
</div>
<a class="anchor" id="ga4aab97e3c902f116f2652c0585665bf3"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_BC00131_LargeBuff_1MB_Unaligned" ref="ga4aab97e3c902f116f2652c0585665bf3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00131_LargeBuff_1MB_Unaligned </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+32 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode, use MAX as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.BC00131_LargeBuff_1MB_Unaligned </dd></dl>

</div>
</div>
<a class="anchor" id="ga35da4c5ad158b2f65c13d3965d1f723f"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00132_MaximumLengthBuffers" ref="ga35da4c5ad158b2f65c13d3965d1f723f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00132_MaximumLengthBuffers </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+32 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode, use MAX as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd><a href="group___manual.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00132_MaximumLengthBuffers </dd></dl>

</div>
</div>
<a class="anchor" id="ga96f880a658691f0e4781c0a9f7510230"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_BC00140_BufferTooLarge" ref="ga96f880a658691f0e4781c0a9f7510230" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00140_BufferTooLarge </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+64 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF: randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer randomly choose an adder from 1 to 32 to add to MAX to calculate the size of the corresponding MEMREF parameter Open a TA of a random mode, use the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd><a href="group___manual.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.BC00140_BufferTooLarge </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c9a8d493cd51ca3d83613acbe022746"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00150_InputBufferReadOnly" ref="ga2c9a8d493cd51ca3d83613acbe022746" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00150_InputBufferReadOnly </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass all combinations of read-only buffers as input parameters. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do from 1-15: set parameters that correspond to the binary equivalent of the loop counter as TEE_PARAM_TYPE_MEMREF_INPUT (i.e. 1 = ?,?,?,I ; 2 = ?,?,I,? ; 9 = I,?,?,I ; and so on...) set other parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of 4096 +/- 32 for all that are output MEMREFs fill the output MEMREF buffers with random data and keep a backup for comparison later allocate buffers from a read-only (code) section for the input MEMREF buffers make a backup of the input MEMREF buffers for comparison later calculate a checksum for the portion that is passed to the TA Open a TA of a random mode, use the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00150_InputBufferReadOnly </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1f409c364dc44d22923f4fd19255d06"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_BC00151_OutputBufferReadOnly" ref="gaa1f409c364dc44d22923f4fd19255d06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00151_OutputBufferReadOnly </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass all combinations of read-only buffers as output parameters. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do from 1-15: set parameters that correspond to the binary equivalent of the loop counter as TEE_PARAM_TYPE_MEMREF_OUTPUT (i.e. 1 = ?,?,?,I ; 2 = ?,?,I,? ; 9 = I,?,?,I ; and so on...) set other parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_OUTPUT, TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of 4096 +/- 32 for all that are output MEMREFs fill the output MEMREF buffers with random data and keep a backup for comparison later allocate buffers from a read-only (code) section for the input MEMREF buffers make a backup of the input MEMREF buffers for comparison later Open a TA of a random mode, use the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer Verify that the TA returned a specific error TEE_ERROR_ACCESS_DENIED </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.BC00151_OutputBufferReadOnly </dd></dl>

</div>
</div>
<a class="anchor" id="gaddb1ab9e270541ceb4d25fe01019e2cd"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_BC00152_InOutBufferReadOnly" ref="gaddb1ab9e270541ceb4d25fe01019e2cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00152_InOutBufferReadOnly </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass all combinations of read-only buffers as output parameters. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do from 1-15: set parameters that correspond to the binary equivalent of the loop counter as TEE_PARAM_TYPE_MEMREF_INOUT (i.e. 1 = ?,?,?,I ; 2 = ?,?,I,? ; 9 = I,?,?,I ; and so on...) set other parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_OUTPUT, TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of 4096 +/- 32 for all that are output MEMREFs fill the output MEMREF buffers with random data and keep a backup for comparison later allocate buffers from a read-only (code) section for the input MEMREF buffers make a backup of the input MEMREF buffers for comparison later Open a TA of a random mode, use the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer Verify that the TA returned a specific error TEE_ERROR_ACCESS_DENIED </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.BC00152_InOutBufferReadOnly </dd></dl>

</div>
</div>
<a class="anchor" id="gab21c59a5aa0516995eb9507b55e89063"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00160_BufferLengthStress" ref="gab21c59a5aa0516995eb9507b55e89063" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00160_BufferLengthStress </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass varying lengths for multiple buffers. Vary the start offset randomly. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 4: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT determine a random size for each buffer, and allocate that size + 32 bytes for all MEMREF inputs fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode, use the length from above as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00160_BufferLengthStress </dd></dl>

</div>
</div>
<a class="anchor" id="ga9aeb03dbf5d9b827c412b100189de946"></a><!-- doxytag: member="00100_BufferSizes_CA2TA_OpenSession.cpp::TestCase_GC00165_BufferLengthStressMultiThreaded" ref="ga9aeb03dbf5d9b827c412b100189de946" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00165_BufferLengthStressMultiThreaded </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Trusted Applications dependencies:</b></dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="user"><dt><b>Pre Conditions:</b></dt><dd>05040000000000000000000000000001.[drbin/tlbin] is loaded. </dd></dl>
<dl class="user"><dt><b>Focus:</b></dt><dd>Pass varying lengths for multiple buffers in multiple parallel threads. </dd></dl>
<dl class="user"><dt><b>Test Steps:</b></dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced run 4 threads with these parameters: do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT determine a random size for each buffer, and allocate that size + 32 bytes for all MEMREF inputs fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode (be careful to track which TAs are in use to avoid calling two of the same type, unless multi-instance), use the length from above as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref </dd></dl>
<dl class="user"><dt><b>Post Conditions:</b></dt><dd>none </dd></dl>
<dl class="user"><dt><b>Manual Execution:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Trustonic Test Suite Testcase:</b></dt><dd><a href="group___tts.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Final Device Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Extensive Testcase:</b></dt><dd><a href="group___extensive.html">Yes</a>  </dd></dl>
<dl class="user"><dt><b>Basic Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Quick Testcase:</b></dt><dd>No </dd></dl>
<dl class="user"><dt><b>Minimum Product Version required for this testcase:</b></dt><dd>400A </dd></dl>
<dl class="user"><dt><b>Test ID:</b></dt><dd>GP_060_BufferLimitations.00100_BufferSizes_CA2TA_OpenSession.GC00165_BufferLengthStressMultiThreaded </dd></dl>

</div>
</div>
</div>
        <br><br>
        <hr>
        <small><em>Copyright (c) 2013-2015 TRUSTONIC LIMITED - TRUSTONIC CONFIDENTIAL</em></small>
    </body>
</html>
