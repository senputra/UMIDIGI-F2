<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<!-- <title>00200_BufferSizes_CA2TA_InvokeCommand</title> -->
<img align="right" width="300" src="TrustonicLogo.jpg">
</br>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group_____buffer_sizes___c_a2_t_a___invoke_command.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">00200_BufferSizes_CA2TA_InvokeCommand<div class="ingroups"><a class="el" href="group___g_p__060___buffer_limitations.html">GP_060_BufferLimitations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab5659aa92417f094c489306ca32586a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#gab5659aa92417f094c489306ca32586a1">TestCase_GC00200_ZeroLengthBuffers</a> ()</td></tr>
<tr class="separator:gab5659aa92417f094c489306ca32586a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacea1775fb46b9864037538c12c9f19a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#gaacea1775fb46b9864037538c12c9f19a">TestCase_GC00210_BufferPageUnalignedAtStart</a> ()</td></tr>
<tr class="separator:gaacea1775fb46b9864037538c12c9f19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9be18a8859ff0f22533f2cb7a529f90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#gad9be18a8859ff0f22533f2cb7a529f90">TestCase_GC00220_BufferPageUnalignedAtEnd</a> ()</td></tr>
<tr class="separator:gad9be18a8859ff0f22533f2cb7a529f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743e0989c20b1c45c690a5c63d05618c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#ga743e0989c20b1c45c690a5c63d05618c">TestCase_GC00230_LargeBuff_1MB_Align4KB</a> ()</td></tr>
<tr class="separator:ga743e0989c20b1c45c690a5c63d05618c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54eee55309e9ec87b6a37974cca6b02f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#ga54eee55309e9ec87b6a37974cca6b02f">TestCase_BC00231_LargeBuff_1MB_Unaligned</a> ()</td></tr>
<tr class="separator:ga54eee55309e9ec87b6a37974cca6b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52382814572bdeb97d98edf0035f2c65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#ga52382814572bdeb97d98edf0035f2c65">TestCase_GC00232_MaximumLengthBuffers</a> ()</td></tr>
<tr class="separator:ga52382814572bdeb97d98edf0035f2c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4eb8a65c790dd90d10a0a4371ad0604"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#gaa4eb8a65c790dd90d10a0a4371ad0604">TestCase_BC00240_BufferTooLarge</a> ()</td></tr>
<tr class="separator:gaa4eb8a65c790dd90d10a0a4371ad0604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga567ab57036fa6d36871fbef9a2f1f437"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#ga567ab57036fa6d36871fbef9a2f1f437">TestCase_GC00250_InputBufferReadOnly</a> ()</td></tr>
<tr class="separator:ga567ab57036fa6d36871fbef9a2f1f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a70984c05638ac0be7b243ecbde607"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#gac7a70984c05638ac0be7b243ecbde607">TestCase_BC00251_OutputBufferReadOnly</a> ()</td></tr>
<tr class="separator:gac7a70984c05638ac0be7b243ecbde607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303b58ad9eeeca98a1fd972b583c326e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#ga303b58ad9eeeca98a1fd972b583c326e">TestCase_BC00252_InOutBufferReadOnly</a> ()</td></tr>
<tr class="separator:ga303b58ad9eeeca98a1fd972b583c326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc32d9f74a7cbb730f8ddf1dcb635b54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#gabc32d9f74a7cbb730f8ddf1dcb635b54">TestCase_GC00260_BufferLengthStress</a> ()</td></tr>
<tr class="separator:gabc32d9f74a7cbb730f8ddf1dcb635b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238bed8de2f0e048d330b645f1a14486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_____buffer_sizes___c_a2_t_a___invoke_command.html#ga238bed8de2f0e048d330b645f1a14486">TestCase_GC00265_BufferLengthStressMultiThreaded</a> ()</td></tr>
<tr class="separator:ga238bed8de2f0e048d330b645f1a14486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Description:</dt><dd>: Verify that various buffer sizes can be used, with attention to boundary conditions. <pre class="fragment">           TEEC_Result TEEC_InvokeCommand(
                      TEEC_Session* session,
                      uint32_t commandID,
                      TEEC_Operation* operation,
                      uint32_t* returnOrigin );

           Same as 00100_BufferSizes_CA2TA_OpenSession, but using TEEC_InvokeCommand()</pre></dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab5659aa92417f094c489306ca32586a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00200_ZeroLengthBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass zero as the length for one to four buffers in various combinations of NONE and MEMREFs </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a random length of 8-128 for all that are not of type NONE fill the buffers with random data and calculate a checksum for each type that is a MEMREF, randomly choose an offset to pass as a start address in the corresponding buffer Open a TA of a random mode with no parameters Call TEE_InvokeCommand() using ZERO as the length for each buffer, and expect '0' as the return value from the TA If the return value is 0: Close the TA Verify that the TA did not die Calculate the checksum again to verify that the buffers did not change</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00200_ZeroLengthBuffers </dd></dl>

</div>
</div>
<a class="anchor" id="gaacea1775fb46b9864037538c12c9f19a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00210_BufferPageUnalignedAtStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass multiple buffers of just over one page in length. Vary the start offset randomly, but fix the end at the exact end of a page. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 15: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate 3 * 4096 bytes for each buffer fix the end of the buffer at the end of the 2nd page randomly choose the length of the buffer to be between 4096 and 4096+16 in size, causing a page overlap near the start of the buffer fill the buffer(s) with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA Open a TA of a random mode with no parameters Call TEEC_InvokeCommand() using the length calculated above for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00210_BufferPageUnalignedAtStart </dd></dl>

</div>
</div>
<a class="anchor" id="gad9be18a8859ff0f22533f2cb7a529f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00220_BufferPageUnalignedAtEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass multiple buffers of just over one page in length. Vary the end position randomly, but fix the start at the exact start of a page. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 15: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate 3 * 4096 bytes for each buffer fix the start of the buffer at the start of the 2nd page randomly choose the length of the buffer to be between 4096 and 4096+16 in size, causing a page overlap near the end of the buffer fill the buffer(s) with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA Open a TA of a random mode with no parameters Call TEEC_InvokeCommand() using the length calculated above for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00220_BufferPageUnalignedAtEnd </dd></dl>

</div>
</div>
<a class="anchor" id="ga743e0989c20b1c45c690a5c63d05618c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00230_LargeBuff_1MB_Align4KB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+32 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode with no parameters Call TEE_InvokeCommand() using MAX as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00230_LargeBuff_1MB_Align4KB </dd></dl>

</div>
</div>
<a class="anchor" id="ga54eee55309e9ec87b6a37974cca6b02f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00231_LargeBuff_1MB_Unaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+32 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode with no parameters Call TEE_InvokeCommand() using MAX as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.BC00231_LargeBuff_1MB_Unaligned </dd></dl>

</div>
</div>
<a class="anchor" id="ga52382814572bdeb97d98edf0035f2c65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00232_MaximumLengthBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+32 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode with no parameters Call TEE_InvokeCommand() using MAX as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd><a href="group___manual.html">Yes</a></dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00232_MaximumLengthBuffers </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4eb8a65c790dd90d10a0a4371ad0604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00240_BufferTooLarge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>05040000000000000000000000000001 6b28a6d436fe5fb9b5ed59cba151a0fc </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass the maximum supported length for one or more buffers. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of MAX+64 for all that are not of type NONE fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF: randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer randomly choose an adder from 1 to 32 to add to MAX to calculate the size of the corresponding MEMREF parameter Open a TA of a random mode with no parameters Call TEEC_InvokeCommand() using the length for each buffer from above, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd><a href="group___manual.html">Yes</a></dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.BC00240_BufferTooLarge </dd></dl>

</div>
</div>
<a class="anchor" id="ga567ab57036fa6d36871fbef9a2f1f437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00250_InputBufferReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass all combinations of read-only buffers as input parameters. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do from 1-15: set parameters that correspond to the binary equivalent of the loop counter as TEE_PARAM_TYPE_MEMREF_INPUT (i.e. 1 = ?,?,?,I ; 2 = ?,?,I,? ; 9 = I,?,?,I ; and so on...) set other parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of 4096 +/- 32 for all that are output MEMREFs fill the output MEMREF buffers with random data and keep a backup for comparison later allocate buffers from a read-only (code) section for the input MEMREF buffers make a backup of the input MEMREF buffers for comparison later calculate a checksum for the portion that is passed to the TA Open a TA of a random mode with no parameters Call TEEC_InvokeCommand() using the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00250_InputBufferReadOnly </dd></dl>

</div>
</div>
<a class="anchor" id="gac7a70984c05638ac0be7b243ecbde607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00251_OutputBufferReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass all combinations of read-only buffers as output parameters. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do from 1-15: set parameters that correspond to the binary equivalent of the loop counter as TEE_PARAM_TYPE_MEMREF_OUTPUT (i.e. 1 = ?,?,?,I ; 2 = ?,?,I,? ; 9 = I,?,?,I ; and so on...) set other parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_OUTPUT, TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of 4096 +/- 32 for all that are output MEMREFs fill the output MEMREF buffers with random data and keep a backup for comparison later allocate buffers from a read-only (code) section for the input MEMREF buffers make a backup of the input MEMREF buffers for comparison later Open a TA of a random mode with no parameters Call TEEC_InvokeCommand() using the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer Verify that the TA returned a specific error TEE_ERROR_ACCESS_DENIED</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.BC00251_OutputBufferReadOnly </dd></dl>

</div>
</div>
<a class="anchor" id="ga303b58ad9eeeca98a1fd972b583c326e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_BC00252_InOutBufferReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass all combinations of read-only buffers as output parameters. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do from 1-15: set parameters that correspond to the binary equivalent of the loop counter as TEE_PARAM_TYPE_MEMREF_INOUT (i.e. 1 = ?,?,?,I ; 2 = ?,?,I,? ; 9 = I,?,?,I ; and so on...) set other parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_OUTPUT, TEE_PARAM_TYPE_MEMREF_INOUT allocate buffers of a length of 4096 +/- 32 for all that are output MEMREFs fill the output MEMREF buffers with random data and keep a backup for comparison later allocate buffers from a read-only (code) section for the input MEMREF buffers make a backup of the input MEMREF buffers for comparison later Open a TA of a random mode with no parameters Call TEEC_InvokeCommand() using the length from above as the length for each buffer, and expect an error as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Verify that there were no changes in each buffer Verify that the TA returned a specific error TEE_ERROR_ACCESS_DENIED</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.BC00252_InOutBufferReadOnly </dd></dl>

</div>
</div>
<a class="anchor" id="gabc32d9f74a7cbb730f8ddf1dcb635b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00260_BufferLengthStress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass varying lengths for multiple buffers. Vary the start offset randomly. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced do loop 100: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT determine a random size for each buffer, and allocate that size + 32 bytes for all MEMREF inputs fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode with no parameters Call TEE_InvokeCommand() using the length from above as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00260_BufferLengthStress </dd></dl>

</div>
</div>
<a class="anchor" id="ga238bed8de2f0e048d330b645f1a14486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TestCase_GC00265_BufferLengthStressMultiThreaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Trusted Applications dependencies:</dt><dd>none </dd></dl>
<dl class="section user"><dt>Focus:</dt><dd>Pass varying lengths for multiple buffers in multiple parallel threads. </dd></dl>
<dl class="section user"><dt>Test Steps:</dt><dd>use a pseudo-random generate, print the seed so the test can be reproduced run 4 threads with these parameters: do loop 32: set parameters to a random combination of TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_MEMREF_OUTPUT, and TEE_PARAM_TYPE_MEMREF_INOUT determine a random size for each buffer, and allocate that size + 32 bytes for all MEMREF inputs fill the buffers with random data and keep a backup for comparison later calculate a checksum for the portion that is passed to the TA for each type that is a MEMREF, randomly choose an offset from 4 to 24 to pass as a start address in the corresponding buffer Open a TA of a random mode with no parameters (be careful to track which TAs are in use to avoid calling two of the same type, unless multi-instance) Call TEE_InvokeCommand() using the length from above as the length for each buffer, and expect a checksum as the return value from the TA If the return value is 0: Verify that the TA did not die Close the TA Else: Verify that the TA died Compare the return value against the checksum that was calculated in the NWd before the api call Verify that there were no changes in the parts of each buffer that are before and after the portion that was passed as a memref</dd></dl>
<dl class="section user"><dt>Manual Execution:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Trustonic Test Suite Testcase:</dt><dd><a href="group___tts.html">Yes</a></dd></dl>
<dl class="section user"><dt>Final Device Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Extensive Testcase:</dt><dd><a href="group___extensive.html">Yes</a></dd></dl>
<dl class="section user"><dt>Basic Testcase:</dt><dd><a href="group___basic.html">Yes</a></dd></dl>
<dl class="section user"><dt>Quick Testcase:</dt><dd>No</dd></dl>
<dl class="section user"><dt>Minimum Product Version required for this testcase:</dt><dd>400A</dd></dl>
<dl class="section user"><dt>Test ID:</dt><dd>GP_060_BufferLimitations.00200_BufferSizes_CA2TA_InvokeCommand.GC00265_BufferLengthStressMultiThreaded </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
        <br><br>
        <hr>
        <small><em>Copyright (c) 2013-2015 TRUSTONIC LIMITED - TRUSTONIC CONFIDENTIAL</em></small>
    </body>
</html>
