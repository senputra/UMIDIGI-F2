package com.mediatek.apmonitor.monitor;

import com.mediatek.apmonitor.IApmKpiMonitor;
import com.mediatek.apmonitor.KpiMonitor;
import com.mediatek.apmonitor.KpiMonitor.*;
import com.mediatek.apmonitor.ApmMsgDefs;
import com.mediatek.apmonitor.kpi.LocationMessage;

import android.content.Context;
import android.content.Intent;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.location.LocationProvider;
import android.location.LocationRequest;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

import java.lang.StringBuilder;


public class LocationMessageKpiMonitor extends KpiMonitor {
    private static final String TAG = "LocationMessageKpiMonitor";
    private static final Short APM_MSG_LOCATION_MESSAGE = ApmMsgDefs.APM_MSG_LOCATION_MESSAGE;
    private static final long REQ_MIN_TIME = 0;
    private static final float REQ_MIN_DISTANCE = 1.0f;
    private static final boolean REQ_NOT_ONE_SHOT = false;
    private MyLocationListener mLocationListener = null;

    public LocationMessageKpiMonitor(Context context, Handler handler) {
        super(context, handler, TAG);
        Log.d(TAG, "LocationMessageKpiMonitor Ctor");
    }

    @Override
    public boolean handleMessage(Message msg) {
        if (msg.what == MSG_ID_APM_KPI_STATE_CHANGED) {
            Short msgId = (Short)msg.obj;
            if (msgId != APM_MSG_LOCATION_MESSAGE) {
                return false;
            }
            LocationManager lm =
                    (LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
            if (lm == null) {
                Log.e(TAG, "Null LocationManager with KPI state changed!");
                return false;
            }
            if (msg.arg1 == EVENT_KPI_ADDED) {
                // To submit when first registration
                Log.d(TAG, "Subscribe APM_MSG_LOCATION_MESSAGE");
                registLocationListener(lm, true);
                return true;
            } else if (msg.arg1 == EVENT_KPI_REMOVED) {
                Log.d(TAG, "Unsubscribe APM_MSG_LOCATION_MESSAGE");
                registLocationListener(lm, false);
                return true;
            }
        }

        return false;
    }

    private void registLocationListener(LocationManager lm, boolean subscribe) {
        if (subscribe) {
            if (mLocationListener == null) {
                mLocationListener = new MyLocationListener();
            }

            LocationRequest request = null;
            // Subscribe network provider
            request = LocationRequest.createFromDeprecatedProvider(
                    LocationManager.NETWORK_PROVIDER,
                    REQ_MIN_TIME,
                    REQ_MIN_DISTANCE,
                    REQ_NOT_ONE_SHOT);
            // request.setHideFromAppOps(true);
            lm.requestLocationUpdates(
                    request,
                    mLocationListener,
                    getHandler().getLooper());
            // Subscribe gps provider
            request = LocationRequest.createFromDeprecatedProvider(
                    LocationManager.GPS_PROVIDER,
                    REQ_MIN_TIME,
                    REQ_MIN_DISTANCE,
                    REQ_NOT_ONE_SHOT);
            // request.setHideFromAppOps(true);
            lm.requestLocationUpdates(
                    request,
                    mLocationListener,
                    getHandler().getLooper());

        } else {
            lm.removeUpdates(mLocationListener);
            mLocationListener = null;
        }
    }

    private final class MyLocationListener implements LocationListener {
        @Override
        public void onLocationChanged(Location location) {
            Log.d(TAG, "onLocationChanged() " + location.toString());
            LocationMessage kpi = new LocationMessage();
            if (LocationManager.NETWORK_PROVIDER.equals(location.getProvider())) {
                kpi.mProvider = LocationMessage.NETWORK_PROVIDER;
            } else if (LocationManager.GPS_PROVIDER.equals(location.getProvider())) {
                kpi.mProvider = LocationMessage.GPS_PROVIDER;
            } else {
                Log.e(TAG, "Unexpected location provider: " + location.getProvider());
                return;
            }
            // Location generated by the LocationManager will have a valid value.
            kpi.mTime = location.getTime();
            kpi.mLatitude = location.getLatitude();
            kpi.mLongitude = location.getLongitude();

            // The following location fields may not exist, use a bit-mask to tell.
            kpi.mFieldsMask = 0;

            if (location.hasAltitude()) {
                kpi.mAltitude = location.getAltitude();
                kpi.mFieldsMask |= LocationMessage.HAS_ALTITUDE_MASK;
            } else {
                kpi.mAltitude = 0.0d;
            }
            if (location.hasSpeed()) {
                kpi.mSpeed = location.getSpeed();
                kpi.mFieldsMask |= LocationMessage.HAS_SPEED_MASK;
            } else {
                kpi.mSpeed = 0.0f;
            }
            if (location.hasBearing()) {
                kpi.mBearing = location.getBearing();
                kpi.mFieldsMask |= LocationMessage.HAS_BEARING_MASK;
            } else {
                kpi.mBearing = 0.0f;
            }
            if (location.hasAccuracy()) {
                kpi.mHorizontalAccuracyMeters = location.getAccuracy();
                kpi.mFieldsMask |= LocationMessage.HAS_HORIZONTAL_ACCURACY_MASK;
            } else {
                kpi.mHorizontalAccuracyMeters = 0.0f;
            }
            if (location.hasVerticalAccuracy()) {
                kpi.mVerticalAccuracyMeters = location.getVerticalAccuracyMeters();
                kpi.mFieldsMask |= LocationMessage.HAS_VERTICAL_ACCURACY_MASK;
            } else {
                kpi.mVerticalAccuracyMeters = 0.0f;
            }
            if (location.hasSpeedAccuracy()) {
                kpi.mSpeedAccuracyMetersPerSecond = location.getSpeedAccuracyMetersPerSecond();
                kpi.mFieldsMask |= LocationMessage.HAS_SPEED_ACCURACY_MASK;
            } else {
                kpi.mSpeedAccuracyMetersPerSecond = 0.0f;
            }
            if (location.hasBearingAccuracy()) {
                kpi.mBearingAccuracyDegrees = location.getBearingAccuracyDegrees();
                kpi.mFieldsMask |= LocationMessage.HAS_BEARING_ACCURACY_MASK;
            } else {
                kpi.mBearingAccuracyDegrees = 0.0f;
            }

            // Build the kpi and submit
            byte[] payload = kpi.build();
            int len = kpi.currentWriteBytes();

            boolean ret = apmSubmitKpi(APM_MSG_LOCATION_MESSAGE, len, payload);
            Log.d(TAG, "submit APM_MSG_LOCATION_MESSAGE, ret = " + ret);
            kpi.close();
        }
        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {}
        @Override
        public void onProviderEnabled(String provider) {}
        @Override
        public void onProviderDisabled(String provider) {}
    }
}
