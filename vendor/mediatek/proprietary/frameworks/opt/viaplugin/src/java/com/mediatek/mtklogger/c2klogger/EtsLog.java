package com.mediatek.mtklogger.c2klogger;

import android.os.SystemProperties;
import android.util.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.Date;
import java.util.List;

/**
 * @author MTK81255
 *
 */
public class EtsLog extends EtsDevice {

    // log file
    FileOutputStream mFileLog = null;
    private int mLogSize = 0;
    private int mLogMaxSize = 0;

    private String mDirLog = null;

    private String mPathDev = null;

    // msgs in cfg
    private List<EtsMsg> mEtsMsgsCfg = new ArrayList<EtsMsg>();
    private List<EtsMsg> mEtsMsgsStop = new ArrayList<EtsMsg>();

    private static final byte[] HEADER_LOG_FILE = new byte[] { 0x53, 0x43, 0x43, 0x53, 0x53,
        0x54, 0x40, 0x45, 0x02, 0x00 };

    private void genStopMsgs() {
        final String[] stopMsgStr = new String[] {
                "00:00:00.0[ Raw Tx: Len=5, 0x65 0x00 0x00 0x00 0x00", // cp spy
                "00:00:00.1[ Raw Tx: Len=6, 0x98 0x08 0x00 0x00 0x00 0x00", // dspm
                                                                            // trace
                "00:00:00.2[ Raw Tx: Len=6, 0x99 0x08 0x00 0x00 0x00 0x00", // dspm
                                                                            // spy
                "00:00:00.3[ Raw Tx: Len=6, 0x80 0x0c 0x00 0x00 0x00 0x00", // dspv
                                                                            // trace
                "00:00:00.5[ Raw Tx: Len=6, 0x81 0x0c 0x00 0x00 0x00 0x00", // dspv
                                                                            // spy
                "00:00:00.6[ Raw Tx: Len=283, 0x64 0x00 0x00 0x00 0x00 0x00 0x13 0x01 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00",
                "00:00:00.7[ Raw Tx: Len=283, 0x64 0x00 0x00 0x00 0x13 0x01 0x13 0x01 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00",
                "00:00:00.8[ Raw Tx: Len=283, 0x64 0x00 0x00 0x00 0x26 0x02 0x13 0x01 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00",
                "00:00:00.9[ Raw Tx: Len=283, 0x64 0x00 0x00 0x00 0x39 0x03 0x13 0x01 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00",
                "00:00:01.0[ Raw Tx: Len=283, 0x64 0x00 0x00 0x00 0x4c 0x04 0x13 0x01 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00" +
                " 0x00 0x00 0x00",
                "00:00:01.1[ Raw Tx: Len=10, 0x64 0x00 0x00 0x00 0x5f 0x05 0x02 0x00 0x00 0x00" };

        for (String msgStr : stopMsgStr) {
            mEtsMsgsStop.add(EtsMsg.parse(msgStr));
        }
    }

    /**
     * download status.
     * @author kma
     */
    public enum LogStatus {
        Logging, // Logging info
        Process, // show process
        Error // error
    }

    /**
     * called when the log process need notify the caller.
     * @author kma
     */
    public interface EtsLogCallback {
        /**
         * @param status LogStatus
         * @param info String
         */
        void onProcess(LogStatus status, String info);
    }

    private EtsLogCallback mCallback = null;

    /**
     * @param sizeMax int
     * @param callback EtsLogCallback
     */
    public EtsLog(int sizeMax, EtsLogCallback callback) {
        super();

        if (sizeMax > 0) {
            mPerLogSize = sizeMax;
        }
        mLogMaxSize = mPerLogSize;

        // set the callback
        if (callback != null) {
            mCallback = callback;
        } else {
            mCallback = new EtsLogCallback() {
                public void onProcess(LogStatus status, String info) {
                    if (status == LogStatus.Error) {
                        Log.e("via_ets", info);
                    } else {
                        Log.i("via_ets", info);
                    }
                }
            };
        }

        // generate stop message
        genStopMsgs();

    }

    /**
     * start the log process.
     * @param pathDev String
     * @param bufBcfg BufferedReader
     * @param dirLog String
     */
    public void start(String pathDev, BufferedReader bufBcfg, String dirLog) {
        Log.i("via_ets", "ets log to be started");

        if (pathDev == null || bufBcfg == null || dirLog == null) {
            Log.e("via_ets", "parameter error!");
        }

        Log.v("via_ets", pathDev);
        Log.v("via_ets", dirLog);

        mDirLog = dirLog;

        // create the ets port device
        mPathDev = pathDev;
        // _callback.onProcess(LogStatus.Logging, "opening the ets device");
        // stopReadThread(false);

        if (isOpened()) {
            Log.e("via_ets", "Log thread has been started");
        }

        // parsing the cfg
        Log.i("via_ets", "Parsing the config file");
        mCallback.onProcess(LogStatus.Logging, "parsing the config file");
        if (!parseCfgFile(bufBcfg)) {
            Log.e("via_ets", "paser bcfg file failed");
        }

        Log.i("via_ets", "ets Log started");
        mCallback.onProcess(LogStatus.Logging, "log process started");
    }

    /**
     * stop the log process.
     */
    public void stop() {
        Log.i("via_ets", "Ets Log to be stopped");

        // reset pause flag
        mStopLogrecord = true;

        try {
            // Wait for read thread exist
            Thread.sleep(100);
            // send stop all spy and all trace
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        // close the port and stop the read thread
        mCallback.onProcess(LogStatus.Logging, "closing ets device");
        stopReadThread(true);
        try {
            // Wait for read thread exist
            Thread.sleep(5000);
            // send stop all spy and all trace
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }

        // close the file
        if (mFileLog != null) {
            try {
                mFileLog.close();
                mFileLog = null;
                mLogSize = 0;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        mCallback.onProcess(LogStatus.Logging, "log process stoped");
    }

    /*
     * @Override protected boolean onError(ErrorCode code){ super.onError(code);
     * if(code==ErrorCode.DevUnvalid){ _callback.onProcess(LogStatus.Error,
     * "CBP is invalid"); // close current Log.i("via_ets", "close the device");
     * closeDevice(); // waiting device to be valid Log.i("via_ets",
     * "wait for ets device occur in 10 seconds");
     * if(!FileUtil.waitFileOccur(_path_dev, 10)){ Log.e("via_ets",
     * "can't find the ets device"); _callback.onProcess(LogStatus.Error,
     * "the device \"" +_path_dev+"\" is disappeared."); return false; }
     * _callback.onProcess(LogStatus.Logging, "restarting the log process"); //
     * open it again try { Thread.sleep(1000); Log.i("via_ets",
     * "try to open it again"); openDevice(null); } catch (Exception e) {
     * _callback.onProcess(LogStatus.Error, "open the device \""
     * +_path_dev+"\" failed."); e.printStackTrace(); return false; } // start
     * the cfg write thread new WriteEtsCfgThread().start(36); return true; }
     * return false; }
     */

    @Override
    protected void onEtsMsgReceived(EtsMsg msg) {

        if (mStopLogrecord) {
            // Log.e("via_ets", "log record is pausing");
            return;
        }

        if (mFileLog == null && mLogSize > 0) {
            Log.e("via_ets", "log file has been destoried?");
            return;
        }

        if (mLogSize == 0 || mLogSize >= mLogMaxSize) {

            // create new log file
            String pathLogFile = mDirLog
                    + new SimpleDateFormat("yyyy.MM.dd_HH.mm.ss").format(new Date()) + ".dat";
            if (!createLogfile(pathLogFile)) {
                destroy();
                mCallback.onProcess(LogStatus.Error, "created log file \"" + pathLogFile
                        + "\" failed.");
                return;
            }

        }

        try {
            // write msgs to log
            byte[] buf = msg.getLogEntry();
            mFileLog.write(buf);

            // _callback.onProcess(LogStatus.Logging, "add a log:"+ buf.length +
            // " bytes");
            mLogSize += buf.length;
            mCallback.onProcess(LogStatus.Process, "Recorded " + mLogSize + " bytes");

        } catch (FileNotFoundException e) {
            mCallback.onProcess(LogStatus.Error, "log file is not created");
            e.printStackTrace();
        } catch (IOException e) {
            mCallback.onProcess(LogStatus.Error, "write log file failed");
            e.printStackTrace();
        }
    }

    /*
     * @Override protected void onEtsMsgReceived(byte[] buffer, int size){ if
     * (_stop_logrecord){ //Log.e("via_ets", "log record is pausing"); return; }
     * if (_fileLog==null && _logSize>0){ Log.e("via_ets",
     * "log file has been destoried?"); return; } if (_logSize==0 ||
     * _logSize>=_logMaxSize) { // create new log file String path_log_file =
     * _dir_log + new SimpleDateFormat("yyyy.MM.dd_HH.mm.ss").format(new Date())
     * + ".dat"; if (!createLogfile(path_log_file)){ destroy();
     * _callback.onProcess(LogStatus.Error, "created log file \"" +
     * path_log_file + "\" failed."); return; } } try { // write msgs to log
     * _fileLog.write(buffer, 0, size); //_callback.onProcess(LogStatus.Logging,
     * "add a log:"+ buf.length + " bytes"); _logSize += size;
     * _callback.onProcess(LogStatus.Process, "Recorded "+ _logSize + " bytes");
     * } catch (FileNotFoundException e) { _callback.onProcess(LogStatus.Error,
     * "log file is not created"); e.printStackTrace(); } catch (IOException e){
     * _callback.onProcess(LogStatus.Error, "write log file failed");
     * e.printStackTrace(); } }
     */

    protected void onEtsMsgReceived(byte[] buffer, int size) {
        if (buffer == null || size <= 0) {
            Log.e("via_ets", "buffer is null!");
            return;
        }
        try {
            // create new log file
            String pathLogFile = mDirLog
                    + new SimpleDateFormat("yyyy.MM.dd_HH.mm.ss").format(new Date()) + ".dat";
            String pathDir = FileUtil.getDirOfPath(pathLogFile);
            File fDir = new File(pathDir);
            if (!fDir.exists() || !fDir.isDirectory()) {
                if (!fDir.mkdirs()) {
                    Log.e("via_ets", "The log file path : " + pathLogFile + " is error!");
                    return;
                }
            }
            Log.i("via_ets", "Write to file " + pathLogFile + ". Buffer size is " + size);
            FileOutputStream fos = new FileOutputStream(pathLogFile);
            fos.write(HEADER_LOG_FILE);
            mCallback.onProcess(LogStatus.Logging, "created log file:" + pathLogFile);

            // fos.write(buffer, header_log_file.length, size);
            fos.write(buffer, 0, size);
            fos.close();
            buffer = null;
            C2KLogRecycle.getInstance().addLogPathToRecycleConfig(pathLogFile);
        } catch (FileNotFoundException e) {
            mCallback.onProcess(LogStatus.Error, "log file is not created");
            e.printStackTrace();
        } catch (IOException e) {
            mCallback.onProcess(LogStatus.Error, "write log file failed");
            e.printStackTrace();
        }
    }

    protected void onEtsMsgReceived(List<EtsMsg> msgs) {
        if (msgs == null || msgs.size() == 0) {
            Log.e("via_ets", "Message output is null!");
            return;
        }
        Log.i("via_ets", "msgs size is " + msgs.size());
        try {
            // create new log file
            String pathLogFile = mDirLog
                    + new SimpleDateFormat("yyyy.MM.dd_HH.mm.ss").format(new Date()) + ".dat";
            String pathDir = FileUtil.getDirOfPath(pathLogFile);
            File fDir = new File(pathDir);
            if (!fDir.exists() || !fDir.isDirectory()) {
                if (!fDir.mkdirs()) {
                    Log.e("via_ets", "The log file path : " + pathLogFile + " is error!");
                    return;
                }
            }
            FileOutputStream fos = new FileOutputStream(pathLogFile);
            fos.write(HEADER_LOG_FILE);
            mCallback.onProcess(LogStatus.Logging, "created log file:" + pathLogFile);

            for (EtsMsg msg : msgs) {
                // write msgs to log
                byte[] buf = msg.getLogEntry();
                fos.write(buf);
            }
            fos.close();
        } catch (FileNotFoundException e) {
            mCallback.onProcess(LogStatus.Error, "log file is not created");
            e.printStackTrace();
        } catch (IOException e) {
            mCallback.onProcess(LogStatus.Error, "write log file failed");
            e.printStackTrace();
        }
    }

    /**
     * @param pathLog String
     * @return Boolean
     */
    private Boolean createLogfile(String pathLog) {
        String pathDir = FileUtil.getDirOfPath(pathLog);

        File fDir = new File(pathDir);
        if (!fDir.exists() || !fDir.isDirectory()) {
            if (!fDir.mkdirs()) {
                return false;
            }
        }

        try {
            if (mFileLog != null) {
                mFileLog.close();
            }

            mFileLog = new FileOutputStream(pathLog);
            mFileLog.write(HEADER_LOG_FILE);
            mLogSize = 10; // the length of header

            mCallback.onProcess(LogStatus.Logging, "created log file:" + pathLog);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            mFileLog = null;
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            mFileLog = null;
            return false;
        }

        return true;
    }

    /**
     * read the bcfg file and parse it in msg list.
     * @param bufBcfg BufferedReader
     * @return Boolean
     */
    private Boolean parseCfgFile(BufferedReader bufBcfg) {
        mEtsMsgsCfg.clear();

        try {
            while (true) {
                String line = bufBcfg.readLine();
                if (line == null) {
                    break;
                }

                EtsMsg msg = EtsMsg.parse(line);
                if (msg != null) {
                    mEtsMsgsCfg.add(msg);
                }
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    private boolean mIsWriteConfigDone = false;
    /**
     * @param open boolean
     */
    public void writeEtsCfgs(boolean open) {
        if (!SystemProperties.get("net.cdma.mdmstat", "").equalsIgnoreCase("ready")) {
            Log.w("via_ets", "Modem is not ready, do not write filter to modme!");
            return;
        }
        try {
            mIsWriteConfigDone = false;
            Log.i("via_ets", open ? "open ets configs" : "close ets configs.");
            mCallback.onProcess(LogStatus.Logging, "start -> writing config/script to ets device");

            List<EtsMsg> msgs = open ? mEtsMsgsCfg : mEtsMsgsStop;
            if (isOpened()) {
                long lastTime = -1;
                for (EtsMsg msg : msgs) {
                    if (lastTime != -1) {
                        try {
                            long sleepTime = msg.mTime - lastTime;
                            if (sleepTime < 0 || sleepTime > 60000) {
                                sleepTime = 0;
                            }
                            Thread.sleep(msg.mTime - lastTime);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } catch (IllegalArgumentException iae) {
                            iae.printStackTrace();
                        }
                    }
                    write(msg);
                    if (msg == null) {
                        return;
                    }
                    lastTime = msg.mTime;
                }
            }
            mCallback.onProcess(LogStatus.Logging, "end -> writing config/script to ets device");
            mIsWriteConfigDone = true;
        } catch (NullPointerException e) {
            Log.w("via_ets", "Maybe the service is stopped during write configfile.");
            mIsWriteConfigDone = true;
            return;
        } catch (ConcurrentModificationException e) {
            Log.w("via_ets",
                    "Maybe the service is stopped during write configfile.");
            mIsWriteConfigDone = true;
            return;
        }
    }

    /**
     * @return boolean
     */
    public boolean isWriteConfigDone() {
        return mIsWriteConfigDone;
    }

    /**
     * @param stop boolean
     */
    public void stopLogRecord(boolean stop) {
        mStopLogrecord = stop;
        if (mStopLogrecord && mFileLog != null) {
            try {
                mFileLog.close();
                mFileLog = null;
                mLogSize = 0;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * @param stop boolean
     */
    public void stopReadThread(boolean stop) {
        if (stop && mWorking) {
            Log.i("via_ets", "Closing the ets device");
            destroy();

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        if (!stop && !mWorking) {
            Log.i("via_ets", "Opening the ets device");

            if (!create(mPathDev)) {
                Log.e("via_ets", "open the ets device failed");
            }

        }

    }
}
